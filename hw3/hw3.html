<!DOCTYPE html>

<html>
    <head>
        <style>
            body {
                font-family: Monospace;
                background-image: linear-gradient(to top, #09203f 0%, #537895 100%);
                margin: 0px;
                overflow: hidden;
            }
            #info {
                position: absolute;
                top: 10px; width: 100%;
                padding: 5px;
                text-align: center;
                font-size: 20px;
                color: #ffffff
            }
            #info a{
                color: #f00;
                font-weight: bold;
                text-decoration: underline;
                cursor: pointer
            }
            button {
                border: none;
                color: white;
                background-color: Transparent;
                border-radius: 8px;
                transition-duration: 0.4s;
                /* Safari */
                transition-duration: 0.4s;
                border: 1px solid #ffffff;
            }
            button:hover {
                border: 1px solid #96B9F2;
                background-color: Transparent;
                color: white;
                box-shadow: 0 5px 20px 0 rgba( 0, 0, 0, 0.54), 0 17px 50px 0 rgba(0, 0, 0, 0.19);
            }
        </style>
    </head>
<body>
	<div id="info">
	    OBJLoader + MTLLoader<br>obj/mtl made by Attila Dob√†k
	</div>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/108/three.min.js"></script>
	<script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://threejs.org/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://threejs.org/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>

<script>
class Obstacal {
    constructor (name, x, y, z) {
//        let maptexture = new THREE.TextureLoader().load( "./circle-icon.png");
//        maptexture.repeat.set(1, 1);
//        maptexture.wrapS = THREE.RepeatWrapping;
//        maptexture.wrapT = THREE.RepeatWrapping;

        this.mesh = new THREE.Mesh (new THREE.CylinderGeometry (8,8,10,20), 
            new THREE.MeshPhongMaterial ({color:0xd0d0d0}));//, map:maptexture
        this.pos = new THREE.Vector3(x,y,z);
        this.mesh.position.copy (this.pos);
        this.touch = false;
        scene.add (this.mesh);
        this.mesh.name = name;
        console.log(name + " been create");
    }
    update(balls) {
        //TODO
    }
}

var camera1, camera2, scene, renderer;
var controls, obj_car;
var keyboard = new KeyboardState();
var clock, useOne = true;
var pos = new THREE.Vector3();
var speed, angle = 0.01, vel;
var theObjectAll, yellow_box, obstacals = [];

var tree_mesh;
var orthoCam;


function loadCubemap() {
    var path = "./yuhi/";
    var format = ".bmp";
    var urls = [
        path + 'posx' + format, path + 'negx' + format,
        path + 'posy' + format, path + 'negy' + format,
        path + 'posz' + format, path + 'negz' + format
        ];
    var loadercube = new THREE.CubeTextureLoader();
    loadercube.setCrossOrigin ('');
    var cubeMap = loadercube.load(urls);
    cubeMap.format = THREE.RGBFormat;
    console.log(cubeMap);
    return cubeMap;
}
function getRandom(min,max){
    return Math.floor(Math.random()*(max-min+1))+min;
};
(function() {
    Math.clamp = function(val,min,max){
        return Math.min(Math.max(val,min),max);
    }
})();

init();
animate();

function init() {
    clock = new THREE.Clock();
    clock_ball = new THREE.Clock();
    scene = new THREE.Scene();
    
    var cubeMap = loadCubemap();
    scene.background = cubeMap;
    
    
    container = document.createElement('div');
    document.body.appendChild(container);

    //camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 20000);
    camera2 = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1500);
    camera2.position.set(0, 50, 100);
    camera2.lookAt(new THREE.Vector3());

    camera1 = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
    camera1.position.z = 500;  // important
    camera1.position.y = 200;  // important
    // scene

    scene = new THREE.Scene();
    gridxz = new THREE.GridHelper (200, 20,'red','white');
    scene.add (gridxz);
    var ambient = new THREE.AmbientLight(0x444444);
    scene.add(ambient);

    var directionalLight = new THREE.DirectionalLight(0xffffff);
    directionalLight.position.set(0, 1, 1).normalize();
    scene.add(directionalLight);

    // model
    var onProgress = function(xhr) {
        if (xhr.lengthComputable) {
          var percentComplete = xhr.loaded / xhr.total * 100;
          console.log(Math.round(percentComplete, 2) + '% downloaded');
        }
    };
    var onError = function(xhr) {};
    //THREE.Loader.Handlers.add(/\.dds$/i, new THREE.DDSLoader());

    var mtlLoader = new THREE.MTLLoader();
    mtlLoader.setPath('model_by_Attila_Dobak/');
    mtlLoader.load('oldcar.mtl', function(materials) {
    materials.preload();
    var objLoader = new THREE.OBJLoader();
    objLoader.setMaterials(materials);
    objLoader.setPath('model_by_Attila_Dobak/');
    objLoader.load('oldcar.obj', function(object) {
        //var theObject =  unitize (object, 20);
        theObjectAll = unitize (object, 20);
        yellow_box = new THREE.BoxHelper (theObjectAll);
        scene.add (theObjectAll);				
        scene.add (yellow_box);
        //////// MATERIAL ADJUSTMENT for porsche ///////////////
        // transparent window: double-side fix
        object.traverse (
            function(mesh) {
				if (mesh instanceof THREE.Mesh) {
				    mesh.material.side = THREE.DoubleSide;
				}
            });
        }, onProgress, onError);

      });

    renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

	controls = new THREE.OrbitControls(camera1, renderer.domElement);
	camera1.position.z = 200;
    window.addEventListener('resize', onWindowResize, false);
    speed = 0.0;
    angle = 0.0;
    
    for(let i = 0; i < 5; i++) {
        obstacals.push (new Obstacal ("target"+i, getRandom(-100,100), 5, getRandom(-100,100)));
    }
    //////////////////////////////// --new
    renderer.autoClear = false;
    
    orthoCam = new THREE.OrthographicCamera(-50, 50, 50, -50, -10, 100);
    
    
    ////////////////////
    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load("./Tree_Texture.png");
    var geometry = new THREE.PlaneGeometry(50,50);
    var material = new THREE.MeshBasicMaterial({
        map:texture,
        alphaTest:0.5
    });
    tree_mesh = new THREE.Mesh(geometry, material);
    tree_mesh.position.y = 25;
    tree_mesh.position.x = 60;
    tree_mesh.position.z = 60;
    scene.add(tree_mesh);
}

////////////////////////////////////////
// create an Object3D of the given object
// so that it is centered at +Y axis
// 
function unitize (object, targetSize) {  
	
	// find bounding box of 'object'
	var box3 = new THREE.Box3();
	box3.setFromObject (object);
	var size = new THREE.Vector3();
	size.subVectors (box3.max, box3.min);
	var center = new THREE.Vector3();
	center.addVectors(box3.max, box3.min).multiplyScalar (0.5);
	console.log ('center: ' + center.x + ', '+center.y + ', '+center.z );
	console.log ('size: ' + size.x + ', ' +  size.y + ', '+size.z );
	
	// uniform scaling according to objSize
	var objSize = findMax (size);
	var scaleSet = targetSize/objSize;
				
	var theObject =  new THREE.Object3D();
    theObject.add (object);
    
	object.scale.set (scaleSet, scaleSet, scaleSet);
	object.position.set (-center.x*scaleSet, -center.y*scaleSet + size.y/2*scaleSet, -center.z*scaleSet);
	return theObject;
	
	
	// helper function
	function findMax(v) {
		if (v.x > v.y) {
			return v.x > v.z ? v.x : v.z;
		} else { // v.y > v.x
			return v.y > v.z ? v.y : v.z;
		} 
	}
			
}

function onWindowResize() {
    camera1.aspect = window.innerWidth / window.innerHeight;
    camera1.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function update(dt) {
    keyboard.update();
    if (keyboard.pressed("A")) {
        angle += 0.01;
    }
    if (keyboard.pressed("D")) {
        angle -= 0.01;
    }
    if (keyboard.pressed("W")) {
        speed -= 0.15;
    }
    if (keyboard.pressed("S")) {
        speed += 0.15;
    }
    if (keyboard.pressed("space")) {
        speed = 0.01;
    }
    speed = Math.clamp (speed, -50, 50.0);
    vel = new THREE.Vector3(speed,0,0);
    vel.applyAxisAngle (new THREE.Vector3(0,1,0), angle);
    pos.add (vel.clone().multiplyScalar(dt));
    //console.log(pos);
}

function animate() {
    
    let camera;
    if(theObjectAll) {
        camera2.position.copy(theObjectAll.localToWorld(new THREE.Vector3(-100, 50, 0)));
        camera2.lookAt(theObjectAll.position);
    }

    if(useOne) camera = camera1;
    else camera = camera2;

    var dt = clock.getDelta();
    update(dt);
    
    controls.update();
    requestAnimationFrame(animate);
    if(theObjectAll) {
        theObjectAll.children[0].position.copy(pos);
        theObjectAll.children[0].position.y = 5;
        theObjectAll.children[0].rotation.y = angle;
        yellow_box.update();
    }
    
    render();
    //renderer.render(scene, camera1);
    
}
function render() {
    renderer.clear();
    tree_mesh.lookAt(new THREE.Vector3(camera1.position.x, 50, camera1.position.z));
    
    let WW = window.innerWidth;
    let HH = window.innerHeight;
    renderer.setViewport(0, 0, WW/2, HH);
    camera1.aspect = WW / 2 / HH;
    camera1.updateProjectionMatrix();
    
    //console.log(theObjectAll);
    //3rd person camera
    if(theObjectAll) {
        let cameraPos = theObjectAll.children[0].localToWorld(new THREE.Vector3(50, 30, 0));
        camera1.position.copy(cameraPos);
        camera1.lookAt(theObjectAll.children[0].position);
        renderer.render(scene, camera1);
    }
    
    ///////////////////////////////////////////////////////
    renderer.setViewport(WW/2, 0, WW/2, HH);
    if(theObjectAll) {
        orthoCam.position.set(theObjectAll.children[0].position.x, 80, theObjectAll.position.z);
        orthoCam.up.set(-1, 0, 0);
        orthoCam.lookAt(theObjectAll.children[0].position);
        renderer.render(scene, orthoCam);
    }
    
}
</script>
</body>

</html>