<!DOCTYPE html>

<html>
    <head>
    <style>
        body {
            font-family: Monospace;
            background-image: linear-gradient(to top, #09203f 0%, #537895 100%);
            margin: 0px;
            overflow: hidden;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            padding: 5px;
            text-align: center;
            font-size: 20px;
            color: #ffffff
        }

        #info a {
            color: #f00;
            font-weight: bold;
            text-decoration: underline;
            cursor: pointer
        }

        button {
            border: none;
            color: white;
            background-color: Transparent;
            border-radius: 8px;
            transition-duration: 0.4s;
            /* Safari */
            transition-duration: 0.4s;
            border: 1px solid #ffffff;
        }

        button:hover {
            border: 1px solid #96B9F2;
            background-color: Transparent;
            color: white;
            box-shadow: 0 5px 20px 0 rgba( 0, 0, 0, 0.54), 0 17px 50px 0 rgba(0, 0, 0, 0.19);
        }
    </style>
</head>

<body>
    <div id="info">
        OBJLoader + MTLLoader<br>obj/mtl made by<br>
        <p id='msg'></p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/108/three.min.js"></script>
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="https://threejs.org/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://threejs.org/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>

    <script>
        var camera, scene, renderer, controls;
        var raycaster, desk_light;
        var mouse = new THREE.Vector2();
        var pickables = [];
        var desklamp_switch_core, desklamp_switch;
        var roomlight_switch_core, roomlight_switch;
        var lit = true, roomlit = true;
        var ambient, directionalLight;
        var materialArray;
        var theObjectAll;
        var sphere;
        
        var walls, wall_entrys;
        var desk_things, desk_entrys;
        
        class Ball_light {
            constructor() {
                this.pos = new THREE.Vector3(-20, 40, -10);
                this.mesh = new THREE.Object3D();
                this.light = new THREE.PointLight();
            }
        }
        
        class Wall {
            constructor() {
                this.pos = new THREE.Vector3();
            }
        }
        class Desk {
            constructor() {
                this.pos = new THREE.Vector3();
            }
        }
        
        init();
        animate();
        function unitize (object, targetSize) {  
            // find bounding box of 'object'
            var box3 = new THREE.Box3();
            box3.setFromObject (object);
            var size = new THREE.Vector3();
            size.subVectors (box3.max, box3.min);
            var center = new THREE.Vector3();
            center.addVectors(box3.max, box3.min).multiplyScalar (0.5);
            console.log ('center: ' + center.x + ', '+center.y + ', '+center.z );
            console.log ('size: ' + size.x + ', ' +  size.y + ', '+size.z );

            // uniform scaling according to objSize
            var objSize = findMax (size);
            var scaleSet = targetSize/objSize;
            var theObject =  new THREE.Object3D();

            theObject.add (object);
            object.scale.set (scaleSet, scaleSet, scaleSet);
            object.position.set (-center.x*scaleSet-22, -center.y*scaleSet + size.y/2*scaleSet+21, -center.z*scaleSet-10);
            return theObject;

            // helper function
            function findMax(v) {
                if (v.x > v.y) {
                    return v.x > v.z ? v.x : v.z;
                } else { // v.y > v.x
                    return v.y > v.z ? v.y : v.z;
                } 
            }
        }
        
        function buildModel(){
            let geometry = new THREE.Geometry();
            let sq11 = Math.sqrt(11);
            
            geometry.vertices.push(new THREE.Vector3(-5, 0, 5));
            geometry.vertices.push(new THREE.Vector3(5, 0, 5));
            geometry.vertices.push(new THREE.Vector3(5, 12, 5));
            geometry.vertices.push(new THREE.Vector3(5, 12 + sq11, 0));
            geometry.vertices.push(new THREE.Vector3(-5, 0, 5));
            geometry.vertices.push(new THREE.Vector3(-5, 12, 5));
            
            let face;
            face = new THREE.Face3(0, 1, 2), face.materialIndex = 0;
            geometry.faces.push(face);
            face = new THREE.Face3(0, 2, 5), face.materialIndex = 0;
            geometry.faces.push(face);
            face = new THREE.Face3(2, 3, 5), face.materialIndex = 0;
            geometry.faces.push(face);
            face = new THREE.Face3(3, 4, 5), face.materialIndex = 0;
            geometry.faces.push(face);
            
            //material position
            geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0)], new THREE.Vector2(1, 1));
            geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 1)], new THREE.Vector2(0, 1));
            
            geometry.computeFaceNormals();
            geometry.computeVertexNormals();
            
            let loader = new THREE.TextureLoader();
            loader.crossOrigin = '';
            let texture = loader.load('./tree_watercolor.jpg');//url
            
            materialArray = [];
            materialArray.push(new THREE.MeshPhongMaterial({map:texture, side: THREE.DoubleSide}),
            new THREE.MeshPhongMaterial({color:'cyan'}));
            return new THREE.Mesh(geometry, materialArray);
        }

        function init() {
            lit = true;
            roomlit = true;
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 100;
            camera.position.y = 50;
            camera.position.x = 100;

            var gridXZ = new THREE.GridHelper(240, 24, 'red', 'white');
            scene.add(gridXZ);

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);

            controls = new THREE.OrbitControls(camera, renderer.domElement);

            document.body.appendChild(renderer.domElement);
            
            ambient = new THREE.AmbientLight(0x444444);
            scene.add(ambient);
            
            directionalLight = new THREE.DirectionalLight(0xffffff);
            directionalLight.position.set(0, 1, 1).normalize();
            scene.add(directionalLight);

            
            /////////////////////////////////////////////////////////////////////
            var desklampswitch = new THREE.Group();
            scene.add(desklampswitch);
            
            desklamp_switch = new THREE.Mesh(new THREE.CylinderGeometry(5, 5, 2, 20), new THREE.MeshPhongMaterial ({color:0xd0d0d0}));
            desklamp_switch.name = 'desklamp_switch'
            desklamp_switch.position.set(-10, 22, 0) //y = 1
            
            desklamp_switch_core = new THREE.Mesh(new THREE.CylinderGeometry(3, 3, 2, 20), new THREE.MeshPhongMaterial ({color:0xed9696}));
            desklamp_switch_core.name = 'desklamp_switch_core'
            desklamp_switch_core.position.set(-10, 23, 0) // y = 2
            desklampswitch.add(desklamp_switch, desklamp_switch_core);

            var roomlightswitch = new THREE.Group();
            scene.add(roomlightswitch);
            
            roomlight_switch = new THREE.Mesh(new THREE.CylinderGeometry(5, 5, 2, 20), new THREE.MeshPhongMaterial ({color:0xd0d0d0}));
            roomlight_switch.name = 'roomlight_switch'
            roomlight_switch.position.set(10, 22, 0)
            
            roomlight_switch_core = new THREE.Mesh(new THREE.CylinderGeometry(3, 3, 2, 20), new THREE.MeshPhongMaterial ({color:0x96b0ed}));
            roomlight_switch_core.name = 'roomlight_switch_core'
            roomlight_switch_core.position.set(10, 23, 0)
            roomlightswitch.add(roomlight_switch, roomlight_switch_core);
            
            pickables = [desklamp_switch_core, roomlight_switch_core];

            raycaster = new THREE.Raycaster();
            document.addEventListener('mousedown', onDocumentMouseDown, false);
            
            scene.add(buildModel());
            
            //////////////////////
            // model
            var onProgress = function(xhr) {
                if (xhr.lengthComputable) {
                  var percentComplete = xhr.loaded / xhr.total * 100;
                  console.log(Math.round(percentComplete, 2) + '% downloaded');
                }
            };
            var onError = function(xhr) {};
            var mtlLoader = new THREE.MTLLoader();
            mtlLoader.setPath('desk_lamp/');
            mtlLoader.load('Desk_lamp.mtl', function(materials) {
                materials.preload();
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('desk_lamp/');
                objLoader.load('Desk_lamp.obj', function(object) {
                    //var theObject =  unitize (object, 20);
                    theObjectAll = unitize (object, 20);
                    //yellow_box = new THREE.BoxHelper (theObjectAll);
                    scene.add (theObjectAll);				
                    //scene.add (yellow_box);
                    //////// MATERIAL ADJUSTMENT for porsche ///////////////
                    // transparent window: double-side fix
                    object.traverse (
                        function(mesh) {
                            if (mesh instanceof THREE.Mesh) {
                                mesh.material.side = THREE.DoubleSide;
                            }
                        }
                    );
                }, onProgress, onError);
            });
            
            //
            //walls
            var cubeGeom = new THREE.BoxGeometry(206, 50, 6);
            var wallMeterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 1,
                side: THREE.DoubleSide,
            });
            let wall_entry = new THREE.Mesh(cubeGeom, wallMeterial);
            walls = [];
            wall_entrys = []
            let PosOfx = [0, 100, 0, -100],
            PosOfz = [100, 0, -100, 0],
            Rotation = [0, 1, 0, 1];

            for (let i = 2; i < 4; i++) {
                let wall = new Wall();
                walls.push(wall);
                let thisMesh = wall_entry.clone();
                if (Rotation[i] == 1) thisMesh.rotation.y = -Math.PI / 2;
                thisMesh.position.set(PosOfx[i], 23.5, PosOfz[i], Rotation[i]);
                wall_entrys.push(thisMesh);
                scene.add(thisMesh)
            }
            
            //Desk
            var cubeGeom = new THREE.BoxGeometry(70, 30, 2);
            var wallMeterial = new THREE.MeshPhongMaterial({
                color: 0xce945b,
                transparent: true,
                opacity: 1,
                side: THREE.DoubleSide,
            });
            let desk_entry = new THREE.Mesh(cubeGeom, wallMeterial);
            desk_things = []
            desk_entrys = []
            PosOfx = [0, 0, 0, 0],
            PosOfz = [0, 0, -100, 0],
            Rotation = [0, 1, 0, 1];

            for (let i = 0; i < 1; i++) {
                let desk = new Desk();
                desk_things.push(desk);
                let thisMesh = desk_entry.clone();
                if (i == 0) thisMesh.rotation.x = -Math.PI / 2;
                thisMesh.position.set(PosOfx[i], 20, PosOfz[i], Rotation[i]);
                desk_entrys.push(thisMesh);
                scene.add(thisMesh)
            }
            
            //
            var sphere_geometry = new THREE.SphereGeometry( 2, 32, 32 );
            var sphere_material = new THREE.MeshPhongMaterial( {color: 0xffff00} );
            sphere = new THREE.Mesh( sphere_geometry, sphere_material );
            sphere.material.emissive = new THREE.Color('yellow');
            sphere.position.set(-19, 38, -10);
            scene.add( sphere );
            
            //light
            desk_light = new THREE.PointLight(0xffffff, 1, 100); //,100
            desk_light.position.set(-19, 38, -10);
            scene.add(desk_light);

            /////////////////////////////////////////////////
        }

        function onDocumentMouseDown(event) {

            // PICKING DETAILS: 
            // convert mouse.xy = [-1,1]^2 (NDC)
            // unproject (mouse.xy, 1) to a point on the far plane (in world coordinate)
            // set raycaster (origin, direction)
            // find intersection objects, (closest first) 
            // each record as
            // [ { distance, point, face, faceIndex, object }, ... ]

            //  event.preventDefault();  // may not be necessary
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // find intersections
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(pickables);
            if (intersects.length > 0) {
                console.log(intersects[0].object.name);
                console.log("desk ligh : " + lit);
                //console.log(intersects[0].object.name == "desklamp_switch_core");
                if(!lit && intersects[0].object.name == "desklamp_switch_core") {
                    desklamp_switch_core.material.emissive = new THREE.Color('black');
                    sphere.material.emissive = new THREE.Color('yellow');
                    desk_light.intensity = 1;
                    lit = !lit; //toggle
                }else if (lit && intersects[0].object.name == "desklamp_switch_core"){
                    desklamp_switch_core.material.emissive = new THREE.Color('red');
                    sphere.material.emissive = new THREE.Color('black');
                    desk_light.intensity = 0;
                    lit = !lit; //toggle
                }
                
                //console.log(intersects[0].object.name);
                console.log("room ligh : " + roomlit);
                if(!roomlit && intersects[0].object.name == "roomlight_switch_core") {
                    roomlight_switch_core.material.emissive = new THREE.Color('black');
                    directionalLight.intensity = 1;
                    roomlit = !roomlit; //toggle
                }else if (roomlit && intersects[0].object.name == "roomlight_switch_core"){
                    roomlight_switch_core.material.emissive = new THREE.Color('blue');
                    directionalLight.intensity = 0;
                    roomlit = !roomlit; //toggle
                }
                $('#msg').text('you have picked ' + '"' + intersects[0].object.name + '"')
            } else {
                $('#msg').text('nothing picked')
            }

        }

        function animate() {
            controls.update();
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>
